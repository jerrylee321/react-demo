#### 首次提交
#### 浏览器工作原理与实践
###### 1，Chrome架构：仅仅打开了1个页面，为什么有4个进程？
* 了解：
 * 浏览器中的网络流程
 * 页面渲染过程
 * JavaScript 执行流程
 * Web 安全理论
* 学习浏览器的多进程架构
  * 并行处理
    - 计算机中的并行处理就是同一时刻处理多个任务
  * 进程和线程
    - 进程： 一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境。
    - 线程是不能单独存在的，它是由进程来启动和管理的。
    - 线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。
    - 进程和线程之间的关系有以下 4 个特点：
      - 1，进程中的任意一线程执行出错，都会导致整个进程的崩溃。
      - 2，线程之间共享进程中的数据，线程之间可以对进程的公共数据进行读写操作。
      - 3，当一个进程关闭之后，操作系统会回收进程所占用的内存。
          - 当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。
      - 4，进程之间的内容相互隔离。
          - 如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了。
   * 单进程浏览器时代 vs 多进程浏览器时代
   * 最新的 Chrome 浏览器包括：
      - 1 个浏览器（Browser）主进程、
      - 1 个 GPU 进程、
      - 1 个网络（NetWork）进程、
      - 多个渲染进程
      - 多个插件进程。

    拓展：
      通常情况下会是五个，但是有很多其他情况：
        1:如果页面里有iframe的话，iframe也会运行在单独的进程中！
        2:如果页面里有插件，同样插件也需要开启一个单独的进程！
        3:如果你装了扩展的话，扩展也会占用进程
        4:如果2个页面属于同一站点的话，并且从a页面中打开的b页面，那么他们会公用一个渲染进程

    * 了解各自进程功能：
      - 浏览器进程： 主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
      - 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
      - GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
      - 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
      - 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

    * 未来谷歌浏览器发展方向： 面向服务架构。
    ```js
     知识拓展：
      * 同一站点(same-site)：我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：
        https://time.geekbang.org
        https://www.geekbang.org
        https://www.geekbang.org:8080
        都是属于同一站点，因为它们的协议都是https，而根域名也都是geekbang.org。你也许了解同源策略，但是同一站点和同源策略还是存在一些不同地方，在这里你需要了解它们不是同一件事就行了。

        Chrome的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。

        直白的讲，就是如果几个页面符合同一站点，那么他们将被分配到一个渲染进程里面去。

        所以，这种情况下，一个页面崩溃了，会导致同一站点的页面同时崩溃，因为他们使用了同一个渲染进程。

        为什么要让他们跑在一个进程里面呢？

        因为在一个渲染进程里面，他们就会共享JS的执行环境，也就是说A页面可以直接在B页面中执行脚本。因为是同一家的站点，所以是有这个需求的。

        * UserAgent，又称为UA，UA是浏览器的身份证，通常，在发送HTTP请求时，UA会附带在HTTP的请求头中user-agent字段中，这样服务器就会知道浏览器的基础信息，然后服务器会根据不同的UA返回不同的页面内容，比如手机上返回手机的样式，PC就返回PC的样式。
          - 获取：
            - 可以在浏览器的控制台中输入：
                navigator.userAgent
                来查看当前浏览器的UA信息。
    ```
###### 2，TCP协议：如何保证页面文件能被完整送达浏览器？
* web 页面性能
  - Web 页面性能的时候有一个重要的指标叫“FP（First Paint）”，是指从页面加载到首次开始绘制的时长。
  - 那什么影响 FP 指标呢？其中一个重要的因素是**网络加载速度**。

* TCP vs UDP
  - 使用 UDP 来传输会存在两个问题:
    - 数据包在传输过程中容易丢失；
    - 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。
    - 使用UDP会带来的缺陷。 UDP不能保证数据可靠，同时也无法确认数据是否送达接收方，不提供重发机制。 这种条件下，决定了UDP适合应用于注重速度且不太关注数据是否完整的领域。如在线视频、互动游戏

  - TCP:传输控制协议,是一种面向连接的、可靠的、基于字节流的传输层通信协议.
    相对于UDP 优势：
      - 对于数据包丢失的情况，TCP 提供重传机制；
      - TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。
      - 和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。
  - 完整的 TCP 连接的生命周期： **建立连接 - 传输数据 - 断开连接 ** 三个阶段
  ```js
    - 完整的TCP 连接：
      - 建立连接：
        该阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。
      - 传输数据阶段:
         在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。
      - 断开连接阶段:
        数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。
  ```
* HTTP 协议是基于 TCP 协议的,你怎么理解 HTTP 和 TCP 的关系？
  - HTTP协议和TCP协议都是TCP/IP协议簇的子集。
    HTTP协议属于应用层，TCP协议属于传输层，HTTP协议位于TCP协议的上层。
    请求方要发送的数据包，在应用层加上HTTP头以后会交给传输层的TCP协议处理，应答方接收到的数据包，在传输层拆掉TCP头以后交给应用层的HTTP协议处理。建立 TCP 连接后会顺序收发数据，请求方和应答方都必须依据 HTTP 规范构建和解析HTTP报文。
    ```js
      这篇文章可以当作平时购物的流程就很清晰的理解：
      数据包： 我们可以理解为我们买的东西；
      TCP/UDP头：买卖人电话、姓名等；
      IP头：买卖双方地址；
      TCP和UDP不同点在于，TCP会把购买的物品直接送到购买人手中，而UDP可能只是送到蜂巢如此之类的。
    ```

###### HTTP请求流程：为什么很多站点第二次打开速度会很快？
* http 初识
  - HTTP 协议，正是建立在 TCP 连接基础之上的。HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，HTTP 也是浏览器使用最广的协议。

  - 疑问：
    1，为什么通常在第一次访问一个站点时，打开速度很慢，当再次访问这个站点时，速度就很快了？
    2，当登录过一个网站之后，下次再访问该站点，就已经处于登录状态了，这是怎么做到的呢？

  - 解决这些疑问，了解完整的 HTTP 请求过程：
    比如 在浏览器地址栏 输入 极客时间 网址：http://time.geekbang.org/index.html， 发生了什么？
    - 1,构建请求：浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。
    ```js
      GET /index.html HTTP1.1
    ```
    - 2, 查找缓存
      在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。
      当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。
      这样做的好处有：缓解服务器端压力，提升性能（获取资源的耗时更短了）；对于网站来说，缓存是实现快速资源加载的重要组成部分。当然，如果缓存查找失败，就会进入网络请求过程了。
    - 3，准备 IP 地址和端口
        - HTTP 和 TCP 的关系
          浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的。

        - 获取IP 和端口
          HTTP 网络请求的第一步是做什么呢？是和服务器建立 TCP 连接。
          那建立连接的信息都有了吗？
           我们讲到建立 TCP 连接的第一步就是需要准备 IP 地址和端口号。
          那怎么获取 IP 地址和端口号呢？
            这得看看我们现在有什么，我们有一个 URL 地址，
          那么是否可以利用 URL 地址来获取 IP 和端口信息呢？
             我们介绍过数据包都是通过 IP 地址传输给接收方的。由于 IP 地址是数字标识，比如极客时间网站的 IP 是 39.106.233.176, 难以记忆，但使用极客时间的域名（time.geekbang.org）就好记多了，所以基于这个需求又出现了一个服务，负责把域名和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做“域名系统”，简称 DNS（Domain Name System）。
          所以，这样一路推导下来，你会发现在第一步浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。
    - 4，等待 TCP 队列
      现在已经把端口和 IP 地址都准备好了，那么下一步是不是可以建立 TCP 连接了呢？答案依然是“不行”。Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。
    - 5，建立 TCP 连接
         排队等待结束之后，终于可以快乐地和服务器握手了，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。
    - 6，发送 HTTP 请求
        一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。

* 浏览器是如何发送请求信息给服务器的？
   - 1，首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。

   - 2，发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是 Get。比如，直接在浏览器地址栏键入极客时间的域名（time.geekbang.org），这就是告诉服务器要 Get 它的首页资源。
  
  - 3，另外一个常用的请求方法是 POST，它用于发送一些数据给服务器，比如登录一个网站，就需要通过 POST 方法把用户信息发送给服务器。如果使用 POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过请求体来发送。 

  - 4，在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。

* 服务器端处理 HTTP 请求流程
 - 服务器会根据浏览器的请求信息来准备相应的内容。
 - 1，返回请求
    - 1，首先服务器会返回响应行，包括协议版本和状态码
    - 2，服务器会通过请求行的状态码来告诉浏览器它的处理结果
    - 3，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。
    - 4，发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。
 - 2，断开连接
   通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：
    ```js
      Connection:Keep-Alive
    ```
    那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。
  - 3. 重定向
    还有一种情况你需要了解下，比如当你在浏览器中打开 geekbang.org 后，你会发现最终打开的页面地址是 https://www.geekbang.org。 这两个 URL 之所以不一样，是因为涉及到了一个重定向操作。
    响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。

* 1. 为什么很多站点第二次打开速度会很快？
  - 如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。
  - 那么，哪些数据会被缓存呢？
    - DNS 缓存 : 主要就是在浏览器本地把对应的 IP 和域名关联起来
    - 页面资源缓存
* 服务器是通过什么方式让浏览器缓存数据的?
  - 第一次请求，当服务器返回 **HTTP 响应头**给浏览器时，浏览器是通过**通过响应头中的 Cache-Control 字段来设置是否缓存该资源**
    通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。
    ```js
      Cache-Control:Max-age=2000
    ```
    在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。
    但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上：
    ```js
     If-None-Match:"4f80f-13c-3a1xb12a"
    ```
    服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。
    如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”如果资源有更新，服务器就直接返回最新资源给浏览器。
    简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。

  * 2. 登录状态是如何保持的？
     1，用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。
     2，服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器。
     ```js
      Set-Cookie: UID=3431uad;
     ```
     3,浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把UID=3431uad保持到本地。
     4, 当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。
     ```js
      Cookie: UID=3431uad;
     ```
     5,服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含UID=3431uad的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。
     6,浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。

     简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。

* 浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：
   - 1,构建请求
   - 2,查找缓存
   - 3,准备 IP 和端口 
   - 4,等待 TCP 队列
   - 5,建立 TCP 连接
   - 6,发起 HTTP 请求
   - 7,服务器处理请求
   - 8,服务器返回请求和断开连接

  * 问题：如果一个页面的网络加载时间过久，你是如何分析卡在哪个阶段的？
  * set cookie 会不会有安全问题？
    cookie是不安全的，比如黑客可以通过一些手段插入一些脚本到你的页面里面（具体一些途径我们浏览器安全篇再讲），通过脚本获取到你的cookie数据，然后就可以利用cookie做一些坏事了。  
    当然也有一些方法规避，常用的一个是将部分cookie设置成httponly的属性，设置了httponly属性后cookie，就无法通过js脚本来读取了，只是在发送http请求时候会被带上！

* 从输入URL到页面展示，这中间发生了什么？
  * 整个过程需要各个进程之间的配合，涉及浏览器进程、渲染进程和网络进程。
  * 浏览器进程主要负责用户交互、子进程管理和文件储存等功能。
  * 网络进程是面向渲染进程和浏览器进程等提供网络下载功能。
  * 渲染进程的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。
    这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。
  * 过程：
      - 首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。
      - 然后，在网络进程中发起真正的 URL 请求。
      - 接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。
      - 浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；
      - 渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；
      - 最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。
      - 浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。
      - 这其中，用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。